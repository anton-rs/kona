[1mdiff --git a/crates/derive/src/sources/ethereum.rs b/crates/derive/src/sources/ethereum.rs[m
[1mindex 22e01bc..97d5e69 100644[m
[1m--- a/crates/derive/src/sources/ethereum.rs[m
[1m+++ b/crates/derive/src/sources/ethereum.rs[m
[36m@@ -3,7 +3,7 @@[m
 [m
 use crate::{[m
     sources::{BlobSource, CalldataSource},[m
[31m-    traits::{BlobProvider, ChainProvider, DataAvailabilityProvider},[m
[32m+[m[32m    traits::{AltDAProvider, BlobProvider, ChainProvider, DataAvailabilityProvider},[m
     types::PipelineResult,[m
 };[m
 use alloc::{boxed::Box, fmt::Debug};[m
[36m@@ -14,50 +14,53 @@[m [muse op_alloy_protocol::BlockInfo;[m
 [m
 /// A factory for creating an Ethereum data source provider.[m
 #[derive(Debug, Clone)][m
[31m-pub struct EthereumDataSource<C, B>[m
[32m+[m[32mpub struct EthereumDataSource<C, B, A>[m
 where[m
     C: ChainProvider + Send + Clone,[m
     B: BlobProvider + Send + Clone,[m
[32m+[m[32m    A: AltDAProvider + Send + Clone,[m
 {[m
     /// The ecotone timestamp.[m
     pub ecotone_timestamp: Option<u64>,[m
     /// The blob source.[m
     pub blob_source: BlobSource<C, B>,[m
     /// The calldata source.[m
[31m-    pub calldata_source: CalldataSource<C>,[m
[32m+[m[32m    pub calldata_source: CalldataSource<C, A>,[m
 }[m
 [m
[31m-impl<C, B> EthereumDataSource<C, B>[m
[32m+[m[32mimpl<C, B, A> EthereumDataSource<C, B, A>[m
 where[m
     C: ChainProvider + Send + Clone + Debug,[m
     B: BlobProvider + Send + Clone + Debug,[m
[32m+[m[32m    A: AltDAProvider + Send + Clone + Debug,[m
 {[m
     /// Instantiates a new [EthereumDataSource].[m
     pub const fn new([m
         blob_source: BlobSource<C, B>,[m
[31m-        calldata_source: CalldataSource<C>,[m
[32m+[m[32m        calldata_source: CalldataSource<C, A>,[m
         cfg: &RollupConfig,[m
     ) -> Self {[m
         Self { ecotone_timestamp: cfg.ecotone_time, blob_source, calldata_source }[m
     }[m
 [m
     /// Instantiates a new [EthereumDataSource] from parts.[m
[31m-    pub fn new_from_parts(provider: C, blobs: B, cfg: &RollupConfig) -> Self {[m
[32m+[m[32m    pub fn new_from_parts(provider: C, blobs: B, altda_provider: Option<A>, cfg: &RollupConfig) -> Self {[m
         let signer =[m
             cfg.genesis.system_config.as_ref().map(|sc| sc.batcher_address).unwrap_or_default();[m
         Self {[m
             ecotone_timestamp: cfg.ecotone_time,[m
             blob_source: BlobSource::new(provider.clone(), blobs, cfg.batch_inbox_address, signer),[m
[31m-            calldata_source: CalldataSource::new(provider, cfg.batch_inbox_address, signer),[m
[32m+[m[32m            calldata_source: CalldataSource::new(provider, altda_provider, cfg.batch_inbox_address, signer),[m
         }[m
     }[m
 }[m
 [m
 #[async_trait][m
[31m-impl<C, B> DataAvailabilityProvider for EthereumDataSource<C, B>[m
[32m+[m[32mimpl<C, B, A> DataAvailabilityProvider for EthereumDataSource<C, B, A>[m
 where[m
     C: ChainProvider + Send + Sync + Clone + Debug,[m
     B: BlobProvider + Send + Sync + Clone + Debug,[m
[32m+[m[32m    A: AltDAProvider + Send + Sync + Clone + Debug,[m
 {[m
     type Item = Bytes;[m
 [m
[36m@@ -82,7 +85,7 @@[m [mmod tests {[m
     use super::*;[m
     use crate::{[m
         sources::BlobData,[m
[31m-        test_utils::{TestBlobProvider, TestChainProvider},[m
[32m+[m[32m        test_utils::{TestAltDAProvider, TestBlobProvider, TestChainProvider},[m
     };[m
     use alloy_consensus::TxEnvelope;[m
     use alloy_eips::eip2718::Decodable2718;[m
[36m@@ -103,7 +106,8 @@[m [mmod tests {[m
         let chain = TestChainProvider::default();[m
         let blob = TestBlobProvider::default();[m
         let cfg = RollupConfig::default();[m
[31m-        let mut calldata = CalldataSource::new(chain.clone(), Address::ZERO, Address::ZERO);[m
[32m+[m[32m        let altda = TestAltDAProvider::default();[m
[32m+[m[32m        let mut calldata = CalldataSource::new(chain.clone(), Some(altda), Address::ZERO, Address::ZERO);[m
         calldata.calldata.insert(0, Default::default());[m
         calldata.open = true;[m
         let mut blob = BlobSource::new(chain, blob, Address::ZERO, Address::ZERO);[m
[36m@@ -124,7 +128,8 @@[m [mmod tests {[m
         let mut blob = default_test_blob_source();[m
         blob.open = true;[m
         blob.data.push(BlobData { data: None, calldata: Some(Bytes::default()) });[m
[31m-        let calldata = CalldataSource::new(chain.clone(), Address::ZERO, Address::ZERO);[m
[32m+[m[32m        let altda = TestAltDAProvider::default();[m
[32m+[m[32m        let calldata = CalldataSource::new(chain.clone(), Some(altda), Address::ZERO, Address::ZERO);[m
         let cfg = RollupConfig { ecotone_time: Some(0), ..Default::default() };[m
 [m
         // Should successfully retrieve a blob batch from the block[m
[36m@@ -149,9 +154,10 @@[m [mmod tests {[m
         let raw_batcher_tx = include_bytes!("../../testdata/raw_batcher_tx.hex");[m
         let tx = TxEnvelope::decode_2718(&mut raw_batcher_tx.as_ref()).unwrap();[m
         chain.insert_block_with_transactions(10, block_ref, alloc::vec![tx]);[m
[32m+[m[32m        let altda = TestAltDAProvider::default();[m
 [m
         // Should successfully retrieve a calldata batch from the block[m
[31m-        let mut data_source = EthereumDataSource::new_from_parts(chain, blob, &cfg);[m
[32m+[m[32m        let mut data_source = EthereumDataSource::new_from_parts(chain, blob,Some(altda),  &cfg);[m
         let calldata_batch = data_source.next(&block_ref).await.unwrap();[m
         assert_eq!(calldata_batch.len(), 119823);[m
     }[m
